<!DOCTYPE html>
<html>
  <head>
    <title>Lecture 7: Combining Data: Attribute joins & spatial analysis</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      body { font-family: 'Droid Serif'; }
      h1, h2, h3 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; }
      .red { color: #fa0000; }
      .white { color: #f3f3f3; }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .footnote { position: absolute; bottom: 1em; font-size: 0.5em;}
      .image-10 img { width: 10%; }
      .image-20 img { width: 20%; }
      .image-30 img { width: 30%; }
      .image-40 img { width: 40%; }
      .image-50 img { width: 50%; }
      .image-60 img { width: 60%; }
      .image-70 img { width: 70%; }
      .image-80 img { width: 80%; }
      .image-90 img {width: 90%;}
      .image-100 img {width: 100%;}
      .image-110 img {width: 110%;}
      .image-120 img {width: 120%;}
      .inverse {
        background: #272822;
        color: #777872;
        <!--text-shadow: 0 0 20px #333;-->
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      /* Two-column layout */
      .left-column { width: 45%; float: left; }
      .right-column { width: 45%; float: right; }
    </style>
  </head>
  <body>
<textarea id="source">

name: base
layout: true
.footnote[GIScience I, Spring 2017]

---

class: inverse, middle
# Lecture 7: Combining Data: Attribute joins & spatial analysis

---

## GIS as process

1. Locate entities in the world.

2. Represent the entities digitally.

3. Describe the entities.

4. **Process, integrate, analyze.**

5. Communicate the results.

6. Audience: Interpret, make decisions, give feedback.

---

## Attribute joins

* Join: Connecting two attribute tables using a common 'key' value.

* Creates a temporary relationship.

* Can have a `one-to-one` or `many-to-one` relationship.

.left-column[
  .image-100[![https://desktop.arcgis.com/en/arcmap/latest/manage-data/tables/about-joining-and-relating-tables.htm](media/GUID-6FF790F5-02F7-4CC5-83AC-17FF1D4EBDA4-web.png)]
  ]
.right-column[
  .image-100[![https://desktop.arcgis.com/en/arcmap/latest/manage-data/tables/about-joining-and-relating-tables.htm](media/GUID-1786A5F6-AEB9-48D5-8071-C94115A4EEA0-web.png)]
  ]

???

* Joins can be made more permanent via creating new output of the combination, or copying values from one table to another.
* Is also `one-to-many` and `many-to-many` relationships, but in GIS joins these are not often included in the standard joins. This is because the spatial representation becomes problematic, when features would require more than one representation (extra rows in table).

---

## Spatial analysis

* Can be thought of as similar to statistical analysis, but including a 2-D coordinate plain.

* However assumptions of statistical analysis are not valid here.

* Spatial analysis are the steps we undertake to convert raw spatial data into the useful information we've set out to get.
  * Add value in transformations, which bring out patterns & anomalies.

* When output combines dataset attributes, can be thought of as a spatial version of a join: joining datasets using the geometry as the key-field.
  * By the complex nature of geometry, has to use different method for linking than `dataset1.key = dataset2.key`.
  * The method by which the geometry are related is the *analysis*.

???

* Statistical assumptions:
  * Normaility: Somewhat normal distribution.
  * Homogeneity of variances: Data from multiple groups have the same variance.
  * Linearity: Data have a linear relationship.
  * Independence: Data are independent.

---

## Types of spatial analysis

Three main types:

1. Analysis based on location (one dimension).

2. Analysis based on distance (two dimensions).

3. Analysis based on area (three dimensions).

---

## 1. Analysis based on location

* Identifying **where** something exists or happens.

* The ability to compare different properties of the same place.
  * Discover relationships, correlations, 'hotspots'.

* Would be convenient if we had data model where every location was represented, with every property attributed directly on it.

* However spatial data models and their implementations tend to emphasize carrying a few properties for all places over a lot of properties for one place.
  * Raster data model limits to one.
  * Maintenance simplicity and "normalization" tends to limit how much one can 'hang' on a single dataset.
  * Horizontal vs. vertical integration of data.

* For that reason, we need ways to be able to collect the properties at a location: to bring all the attributes into a single feature.

???

* Normalization is the concept that a system shouldn't have more than one copy of a piece of data.
  * Using Duckweb as an example: your name should only be written in one place.
  * If another part of the system needs your name, it would just store an ID attribute (95 number) to connect one to the other.
  * That way if you ever changed your name, the change would automatically be available to all references, wih only a single update.

---

## 1a. 'Spatial' attribute join

* Spatial join is the same as an attribute join, but in this case the key value defines a spatial relationship

* Example: Using a base feature class with cities' economic information; want to add some state-level info, e.g. unemployment.
  * So long as the cities have their state as an attribute (name, code, FIPS), should be joinable via their relationship.
  * **BE SURE** to not assume state attributes are equivalent to city attributes: properly document.

???

* 'Spatial join' is somewhat problematic here. Spatial join commonly used to refer to spatial analysis tools that combine dataset attributes in general.
---

## 1b. Point-in-polygon operation

.left-column[
* Determining whether a point lies inside or outside a polygon (also: which polygon?).

* It's quite useful to apply areal properties to point locations.
  ]
.right-column[
* Probably the most-used operation for assigning attributes to features (even non-point!).
  * What boundaries does it lie in? City, district, Census, neighborhood?
  * What areal classifications does it lie in? Zoning, flood areas, wetlands.
  ]

.image-100[![http://giscommons.org/analysis/](media/5.12.gif)]

???

* Yes, even non-point features can use point-in-polygon, by 'pretending' to be a point (centroid).
* Though not as easy to compute as an attribute join, still quite simple to solve.

---

## 1c. Polygon overlay

* Similar to point-in-polygon, as two objects are involved.

* Combination of two or more sets of features, essentially creating a new set of features.

* Geometry is 'split' to define the spatial extent of the combinations.

* Slivers: When a boundary line occurs in multiple input datasets but isn't an exact match.
  * Oddly: better data collection almost always **causes** more of these.

![https://desktop.arcgis.com/en/arcmap/latest/tools/coverage-toolbox/identity.htm](media/GUID-E0535FDB-1F08-418C-B6E9-EB27FDC490D4-web.gif)

???

* Better data causes slivers: More data points on the line = more ever-tinier ones.

---

## 2. Analysis based on distance

##TODO: FINISH FROM HERE

---

## 3. Analysis based on area

</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
